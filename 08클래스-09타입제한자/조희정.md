<br/><br/><br/>

<h1 align="center">Learning TypeScript 8~9</h1>

<br/>

# 클래스

### 클래스 메서드

1. 매개변수 타입과 기본값
   1. 메서드 매개변수에 타입이나 기본값이 없으면 기본적으로 `any` 타입이다.
2. 인수 개수 검사
   1. 메서드를 호출할 때 적절한 수의 인수를 제공해야 한다.
3. 생성자
   1. 생성자도 클래스의 메서드처럼 다뤄지며 매개변수 타입과 인수 개수를 검증한다.

```tsx
class Greeter {
  greet(name: string) {
    console.log(`${name}, do your stuff!`);
  }
}
new Greeter().greet("Miss Frizzle"); // Ok
new Greeter().greet(); // Error: Expected 1 argument, but got 0.

class Greeted {
  constructor(message: string) {
    console.log(`As I always say: ${message}!`);
  }
}
new Greeted("take chances, make mistakes, get messy"); // Ok
new Greeted(); // Error: Expected 1 argument, but got 0.
```

### 클래스 속성

타입 스크립트에서 클래스 속성은 명시적으로 선언해야만 읽거나 쓸 수 있다.

1. 클래스 속성 선언
   1. `변수명: 타입;`
2. 생성자 내 속성 초기화
   1. 생성자에서 선언되지 않은 속성을 할당할 수 없도록 강제한다.
3. 정확한 속성 접근 보장
   1. 속성을 명시적으로 선언하면, 해당 클래스 인스턴스가 가질 속성을 정확히 파악할 수 있다.

```tsx
class FieldTrip {
  destination: string;

  constructor(destination: string) {
    this.destination = destination; // Ok
    console.log(`We're going to ${this.destination}!`);
    this.nonexistent = destination; // Error: Property 'nonexistent' does not exist on type 'FieldTrip'.
  }
}

const trip = new FieldTrip("planetarium");
trip.destination; // Ok
trip.nonexistent; // Error: Property 'nonexistent' does not exist on type 'FieldTrip'.
```

**메서드**

함수를 메서드로 정의해 클래스 프로토타입에 할당한다.

모든 인스턴스가 동일한 함수 정의를 참조해 메모리 관리에 효율적이다.

```tsx
class WithMethod {
  myMethod() {}
}
new WithMethod().myMethod === new WithMethod().myMethod; // true
```

**함수 속성**

속성으로 함수를 정의할 수 있다.

클래스 인스턴스마다 새로운 함수가 생성되므로 `this` 스코프가 유지되며 인스턴스별로 고유한 함수가 생성된다.

```tsx
class WithPropertyParameters {
  takesParameters = (input: boolean): string => (input ? "Yes" : "No");
}
const instance = new WithPropertyParameters();
instance.takesParameters(true); // "Yes"
instance.takesParameters(123); // Error: Argument of type 'number' is not assignable to parameter of type 'boolean'.
```

**엄격한 초기화 검사**

클래스 속성에 값을 할당하지 않는 실수를 방지하는 기능

- 초기화 검사의 필요성

  - 속성이 생성자에서 할당되지 않으면, 그 속성은 `undefined`가 되어 오류를 일으킬 수 있다.

  ```tsx
  class WithValue {
    immediate = 0; // Ok
    later: number; // Ok (생성자에서 할당)
    mayBeUndefined: number | undefined; // Ok (undefined 허용)
    unused: number; // Error: 초기화되지 않음

    constructor() {
      this.later = 1;
    }
  }
  ```

- 할당 어서션 연산자 `!`

  - 생성자 외부에서 속성을 초기화해야 할 때 `!`를 속성 이름 뒤에 붙여 초기화 검사를 비활성화할 수 있다.
    > `!`를 사용하는 것은 타입 안정성을 줄이므로 최대한 사용하지 않도록 설계하는 것이 좋다.

  ```tsx
  class ActivitiesQueue {
    pending!: string[]; // Ok (생성자 외부에서 초기화)

    initialize(pending: string[]) {
      this.pending = pending;
    }

    next() {
      return this.pending.pop();
    }
  }

  const activities = new ActivitiesQueue();
  activities.initialize(["eat", "sleep", "learn"]);
  activities.next();
  ```

**선택적 속성**

속성 이름 뒤에 `?`를 추가하여 선택적 속성으로 선언할 수 있다.

선택적 속성은 `undefined`를 포함하는 유니언 타입처럼 동작하므로 반드시 초기화하지 않아도 된다.

```tsx
class MissingInitializer {
  property?: string;
}
const instance = new MissingInitializer();
instance.property?.length; // Ok (undefined 체크)
instance.property.length; // Error: Object is possibly 'undefined'
```

**읽기 전용 속성**

`readonly` 키워드를 사용해 속성을 읽기 전용으로 선언할 수 있다.

선언된 위치나 생성자에서만 초기화할 수 있다.

- `readonly`로 선언된 원시 타입 속성은 리터럴 타입으로 좁혀져 값 변경 가능성을 줄이고 안정성을 높인다.

```tsx
class RandomQuote {
  readonly explicit: string = "Home is the nicest word there is.";
  readonly implicit = "Home is the nicest word there is."; // 리터럴 타입으로 추론

  constructor() {
    if (Math.random() > 0.5) {
      this.explicit = "Another quote"; // Ok
      this.implicit = "Another quote"; // Error: Type mismatch
    }
  }
}
```

> `readonly`는 타입스크립트에서만 적용되기 때문에 진정한 읽기 전용 보호가 필요하다면 `#`프라이빗 필드나 `get()` 함수 속성 사용을 고려하는 것이 좋다.

### 타입으로서의 클래스

타입스크립트에서 클래스는 런타임 값(클래스 자체)과 타입(타입 애너테이션에서 사용)을 동시에 생성한다.

1. 클래스의 타입 역할

   1. 클래스 선언은 해당 클래스를 타입으로도 사용할 수 있게 한다.

   ```tsx
   class Teacher {
     sayHello() {}
   }

   let teacher: Teacher;
   teacher = new Teacher(); // Ok
   teacher = "Wahoo!"; // Error: Type 'string' is not assignable to type 'Teacher'
   ```

2. 구조적 타이핑

   1. 클래스의 형태가 동일하다면 해당 클래스를 가지지 않는 객체도 클래스 타입으로 인정한다.
   2. 클래스의 멤버와 동일한 멤버를 가진 객체라면, 클래스 타입으로 사용할 수 있다.
   3. 클래스 타입을 요청할 때, 실제 클래스 인스턴스 뿐 아니라 해당 구조와 동일한 객체도 허용한다. → 타입 검사의 유연성

   ```tsx
   class SchoolBus {
     getAbilities() {
       return ["magic", "shapeshifting"];
     }
   }

   function withSchoolBus(bus: SchoolBus) {
     console.log(bus.getAbilities());
   }

   withSchoolBus(new SchoolBus()); // Ok
   withSchoolBus({ getAbilities: () => ["transmogrification"] }); // Ok
   withSchoolBus({ getAbilities: () => 123 }); // Error: Type 'number' is not assignable to type 'string[]'
   ```

### 클래스와 인터페이스

1. 클래스가 인터페이스를 구현

   1. `implements` 키워드를 사용하여 클래스가 특정 인터페이스를 준수하도록 지정할 수 있다.
   2. 인터페이스를 구현한 클래스는 인터페이스의 모든 속성과 메서드를 포함해야 한다.

   ```tsx
   interface Learner {
     name: string;
     study(hours: number): void;
   }

   class Student implements Learner {
     name: string;

     constructor(name: string) {
       this.name = name;
     }

     study(hours: number) {
       for (let i = 0; i < hours; i++) {
         console.log("... studying ...");
       }
     }
   }

   class Slacker implements Learner {
     // Error: Class 'Slacker' incorrectly implements interface 'Learner'
     // 'study' method is missing
     name = "Rocky";
   }
   ```

2. 메서드와 속성 타입 일치 요구
   1. 인터페이스에서 정의된 메서드나 속성 타입이 클래스 구현과 정확히 일치해야 한다.
   2. 타입스크립트는 인터페이스의 타입을 클래스에 자동으로 적용하지 않으므로 직접 타입 애너테이션을 추가해야 한다.
3. 암시적 `any` 오류

   1. 인터페이스를 구현하면서 타입을 지정하지 않으면, 타입스크립트는 암시적 `any`로 처리해 오류를 발생시킨다.

   ```tsx
   class Student implements Learner {
     name; // Error: 'name' implicitly has an 'any' type

     study(hours) {
       // Error: 'hours' implicitly has an 'any' type
       // implementation
     }
   }
   ```

4. 인터페이스 구현의 목적
   1. 타입 안정성 강화
   2. 인터페이스를 구현한다고 해서 모든 인터페이스 멤버가 자동으로 클래스에 복사되지는 않으며, 인터페이스를 준수하지 않는 클래스는 타입 오류를 통해 확인된다. → 타입 오류를 쉽게 식별할 수 있다.

**다중 인터페이스**

클래스가 여러 인터페이스를 동시에 구현할 수 있으며 인터페이스 목록은 쉼표로 구분한다.

모든 인터페이스의 속성 및 메서드를 충족해야 하며, 그렇지 않으면 타입 오류가 발생한다.

```tsx
interface Graded {
  grades: number[];
}

interface Reporter {
  report: () => string;
}

class ReportCard implements Graded, Reporter {
  grades: number[];

  constructor(grades: number[]) {
    this.grades = grades;
  }

  report() {
    return this.grades.join(", ");
  }
}

class Empty implements Graded, Reporter {}
// Error: 'grades' and 'report' properties are missing
```

- 충돌

  - 두 인터페이스가 같은 이름의 속성을 서로 다른 타입으로 정의하면 클래스를 구현할 때 충돌이 발생한다.
  - 두 인터페이스가 다른 객체 형태를 표현하는 경우 단일 클래스에서 이를 구현하는 것은 안 좋다.
  - 클래스의 역할이 명확하게 분리되도록 설계하거나 하나의 클래스로 구현이 필요하다면 속성 이름이나 구조를 변경해 충돌을 피할 수 있다.

  ```tsx
  interface AgelsANumber {
    age: number;
  }

  interface AgelsNotANumber {
    age: () => string;
  }

  class AsNumber implements AgelsANumber, AgelsNotANumber {
    age = 0;
    // Error: 'number' 타입은 '() => string' 타입에 할당할 수 없음
  }

  class NotAsNumber implements AgelsANumber, AgelsNotANumber {
    age() {
      return "";
    }
    // Error: '() => string' 타입은 'number' 타입에 할당할 수 없음
  }
  ```

### 클래스 확장

타입스크립트의 클래스 확장 기능은 자바스크립트에서의 상속 개념에 타입 검사를 추가하여 더 안정적인 코드 작성을 돕는다.

**클래스 확장과 기본/하위 클래스 개념**

기본 클래스에 선언된 모든 속성과 메서드는 하위 클래스에서 사용할 수 있다.

```tsx
class Teacher {
  teach() {
    console.log("The surest test of discipline is its absence.");
  }
}

class StudentTeacher extends Teacher {
  learn() {
    console.log("Learning in progress...");
  }
}

const teacher = new StudentTeacher();
teacher.teach(); // Ok
teacher.learn(); // Ok
```

**할당 가능성 확장**

하위 클래스는 기본 클래스의 모든 속성을 상속하므로 기본 클래스의 인스턴스가 필요한 곳에 하위 클래스 인스턴스를 사용할 수 있다.

- 하지만 하위 클래스에만 있는 속성은 기본 클래스에서 사용할 수 없다.

```tsx
class Lesson {
  subject: string;

  constructor(subject: string) {
    this.subject = subject;
  }
}

class OnlineLesson extends Lesson {
  url: string;

  constructor(subject: string, url: string) {
    super(subject);
    this.url = url;
  }
}

let lesson: Lesson;
lesson = new Lesson("Math"); // Ok
lesson = new OnlineLesson("Science", "example.com"); // Ok

let online: OnlineLesson;
online = new OnlineLesson("Art", "example.com"); // Ok
online = new Lesson("History"); // Error: `url` 속성이 누락됨
```

**재정의 된 생성자**

하위 클래스가 자체 생성자를 재정의할 필요는 없지만, 하위 클래스가 생성자를 정의할 경우 `super()`를 통해 기본 클래스 생성자를 호출해야 하며, 이를 통해 올바른 매개변수를 전달하는지 확인한다.

```tsx
class GradeAnnouncer {
  message: string;

  constructor(grade: number) {
    this.message = grade >= 65 ? "You pass!" : "Maybe next time...";
  }
}

class PassingAnnouncer extends GradeAnnouncer {
  constructor() {
    super(100); // Ok
  }
}

class FailingAnnouncer extends GradeAnnouncer {
  constructor() {
    // Error: 하위 클래스의 생성자에서 `super` 호출이 필요
  }
}
```

- `super` 호출 규칙
  - 하위 클래스의 생성자는 `this`나 `super`에 접근하기 전에 반드시 `super()`를 호출해야 한다.

**재정의 된 메서드**

하위 클래스에서 기본 클래스에서 동일한 이름의 메서드를 다시 선언할 수 있다. 이때 메서드의 매개변수와 반환 타입이 기본 클래스의 메서드와 호환되어야 한다.

```tsx
class GradeCounter {
  countGrades(grades: string[], letter: string): number {
    return grades.filter((grade) => grade === letter).length;
  }
}

class FailureCounter extends GradeCounter {
  countGrades(grades: string[]): number {
    return super.countGrades(grades, "F");
  }
}

class AnyFailureChecker extends GradeCounter {
  countGrades(grades: string[]): boolean {
    // Error: 반환 타입 불일치
    return super.countGrades(grades, "F") !== 0;
  }
}

const counter: GradeCounter = new AnyFailureChecker();
const count = counter.countGrades(["A", "B", "F"]); // 예상 타입: number, 실제 타입: boolean
```

**재정의 된 속성**

하위 클래스는 기본 클래스의 속성과 동일한 이름의 속성을 재정의할 수 있지만 기본 클래스의 타입과 호환되어야 한다. → 기본 클래스 속성 타입의 더 좁은 하위 집합으로 정의하거나 상속받은 타입으로 확장한다.

```tsx
class Assignment {
  grade?: number;
}

class GradedAssignment extends Assignment {
  grade: number; // 항상 number가 존재하도록 구체화

  constructor(grade: number) {
    super();
    this.grade = grade;
  }
}
```

- 속성 타입 확장 불가

  - 속성 타입을 유니언 타입으로 확장하여 더 넓은 범위를 갖게 할 수 없다.

  ```tsx
  class NumericGrade {
    value = 0;
  }

  class VagueGrade extends NumericGrade {
    value = Math.random() > 0.5 ? 1 : "..."; // Error: `string`이 `number` 타입에 할당될 수 없음
  }

  const instance: NumericGrade = new VagueGrade();
  instance.value; // 예상 타입: number, 실제 타입: number | string
  ```

### 추상 클래스

타입스크립트의 **추상 클래스**는 일부 메서드를 선언만 하고, 구현은 하지 않아 하위 클래스에서 구현할 것을 요구하는 방식으로 사용된다.

**추상 클래스와 메서드**

`abstract` 키워드를 클래스와 메서드 앞에 붙여 추상 클래스를 정의한다. 추상 클래스는 인스턴스를 생성할 수 없으며, 추상 메서드는 하위 클래스에서 반드시 구현해야 한다.

```tsx
abstract class School {
  readonly name: string;

  constructor(name: string) {
    this.name = name;
  }

  abstract getStudentTypes(): string[];
}

class Preschool extends School {
  getStudentTypes() {
    return ["preschooler"];
  }
}

class Absence extends School {} // Error: 추상 메서드 `getStudentTypes`를 구현하지 않음
```

**인스턴스화 제한**

추상 클래스는 구현되지 않은 메서드를 포함하기 때문에 직접 인스턴스화 할 수 없다. 하위 클래스만 인스턴스화 할 수 있다.

```tsx
let school: School;
school = new Preschool("Sunnyside Daycare"); // Ok
school = new School("somewhere else"); // Error: 추상 클래스는 인스턴스화할 수 없음
```

**추상 클래스의 용도**

- 추상 클래스는 클래스의 **기본 구조**를 정의하면서 세부 사항은 하위 클래스에서 제공하도록 요구할 때 사용한다.
- 주로 프레임워크나 공통 기능을 제공하는 라이브러리에서 사용되며, 특정 인터페이스를 준수하도록 강제하면서도 공통 구현을 제공할 수 있다.
- **필수적인 메서드 구조를 정의**하면서 **구현 세부 사항을 하위 클래스에 위임**하여, 일관성을 유지하면서도 유연성을 제공한다.

### 멤버 접근성

타입스크립트에서 클래스 멤버 접근성은 **public**, **protected**, **private** 키워드를 통해 제어된다. 자바스크립트의 `#` private 필드와 타입스크립트의 접근성 제어 방식은 서로 다른 특성을 가지고 있다.

**접근성 키워드**

- `public`: 모든 곳에서 접근 가능하며, 기본 접근성이다.
- `protected`: 클래스와 하위 클래스에서만 접근 가능하다.
- `private`: 해당 클래스 내부에서만 접근할 수 있다.
- `#` \*\*\*\*(자바스크립트 private 필드): 해당 클래스 내부에서만 접근 가능한 진정한 private 필드이다. 컴파일된 자바스크립트 코드에서도 외부 접근이 불가능하다.

**타입스크립트와 자바스크립트의 차이점**

- 타입스크립트의 `protected` 및 `private` 키워드는 타입 시스템에만 존재하며, 컴파일된 자바스크립트에서는 모두 `public`으로 변환된다.
- 자바스크립트의 `#` private 필드는 런타임에서도 외부 접근이 불가능하며, 진정한 `private` 멤버로 작동한다.

**접근성 키워드와 readonly**

- `readonly`와 접근성 키워드는 함께 사용할 수 있으며, `readonly`를 통해 값을 한 번만 할당할 수 있도록 제한할 수 있다.
- `readonly` 키워드를 사용할 때는 접근성 키워드를 먼저 적는다.

```tsx
class TwoKeywords {
  private readonly name: string;

  constructor() {
    this.name = "Anne Sullivan"; // Ok
  }

  log() {
    console.log(this.name); // Ok
  }
}

const two = new TwoKeywords();
two.name = "Savitribai Phule"; // Error: 'name'은 private이자 readonly로 수정 불가
```

**`#` private 필드와 타입스크립트의 `private` 키워드의 혼용 제한**

- 자바스크립트의 `#` private 필드는 기본적으로 private이므로 타입스크립트에서 `private` 키워드를 추가할 필요가 없다.
- `private` 키워드와 `#` 필드를 동시에 사용할 수 없다.

**정적 필드 제한자**

자바스크립트와 타입스크립트에서 `static` 키워드를 사용하여 클래스 자체에 속하는 정적 필드를 선언할 수 있다. 타입스크립트에서는 여기에 **readonly**와 **접근성 제한자**(`public`, `protected`, `private`)를 조합하여 사용할 수 있다. 이때, 접근성 키워드를 가장 먼저 적어야 한다.

- **static** 필드는 클래스의 인스턴스가 아닌 클래스 자체에 속하므로, 인스턴스가 아닌 클래스 이름을 통해 접근한다.
- 타입스크립트에서는 정적 필드에 **readonly** 및 접근성 제한자를 함께 사용하여, 접근성과 수정 가능성을 제한할 수 있다.

```tsx
class Question {
  protected static readonly answer = "bash";
  protected static readonly prompt =
    "What's an ogre's favorite programming language?";

  guess(getAnswer: (prompt: string) => string) {
    const answer = getAnswer(Question.prompt); // Ok
    if (answer === Question.answer) {
      console.log("You got it!");
    } else {
      console.log("Try again...");
    }
  }
}

Question.answer; // Error: 'answer'는 protected이므로 클래스 외부에서 접근할 수 없음
```

# 타입 제한자

### top 타입

시스템에서 가능한 모든 값을 나타내며, 모든 타입은 top 타입에 할당할 수 있다.

1. `any`

   - `any` 타입은 모든 타입의 값을 허용하며, 타입스크립트의 타입 검사기를 비활성화한다.
   - 타입 안정성이 부족해, `any`로 선언된 변수는 오류 없이 어떤 작업이든 수행할 수 있지만, 이는 런타임에서 예기치 않은 오류를 유발할 수 있다.

   ```tsx
   let anyValue: any;
   anyValue = "Lucille Ball"; // Ok
   anyValue = 123; // Ok
   console.log(anyValue); // Ok

   function greetComedian(name: any) {
     console.log(`Announcing ${name.toUpperCase()}!`); // 타입 오류 없음
   }

   greetComedian({ name: "Bea Arthur" }); // Runtime error: name.toUpperCase is not a function
   ```

2. `unknown`

   - `unknown`은 타입스크립트의 진정한 top 타입이다. 모든 값은 `unknown` 타입에 할당될 수 있다.
   - `unknown`과 `any`의 주요 차이점은 **타입스크립트가 `unknown` 타입을 훨씬 더 제한적으로 취급**한다는 점이다.
     - `unknown` 타입의 값에 바로 접근할 수 없다.
     - `unknown` 타입은 top 타입이 아닌 다른 타입으로 바로 할당할 수 없다.
   - `unknown` 타입의 값을 사용하려면 **타입을 좁히는 과정**이 필요하다. 예를 들어, `typeof`, `instanceof`, 또는 타입 어서션을 통해 `unknown` 타입을 특정 타입으로 제한해야 한다.

   ```tsx
   function greetComedian(name: unknown) {
     console.log(`Announcing ${name.toUpperCase()}!`); // Error: Object is of type 'unknown'
   }

   function greetComedianSafety(name: unknown) {
     if (typeof name === "string") {
       console.log(`Announcing ${name.toUpperCase()}!`); // Ok
     } else {
       console.log("Input is not a string.");
     }
   }

   greetComedianSafety("Betty White"); // Logs: Announcing BETTY WHITE!
   greetComedianSafety({}); // Logs: Input is not a string.
   ```

3. `unknown`이 `any`보다 안전한 이유
   - `unknown` 타입은 직접적인 속성 접근이 불가능하고, 특정 타입으로 좁혀야만 사용 가능하므로 타입 안정성을 보장한다.

### 타입 서술어

함수의 반환 타입으로 특정 타입임을 나타내어 타입 가드(type guard)로 사용될 수 있다.

- `typeof`나 `instanceof`와 같이 타입을 좁히는 방식은 함수 외부에서만 효과적이다.
- 타입 서술어를 사용하면 특정 조건에서 함수의 반환 값이 `boolean`이 아닌 **타입 판별을 위한 조건**으로 작동하여 인수의 타입을 좁힐 수 있다.

```tsx
function typePredicate(input: WideType): input is NarrowType;
```

- 타입 서술어는 특정 객체가 더 구체적인 인터페이스를 구현했는지 확인하는 데도 사용할 수 있다.

```tsx
interface Comedian {
  funny: boolean;
}
interface StandupComedian extends Comedian {
  routine: string;
}

function isStandupComedian(value: Comedian): value is StandupComedian {
  return "routine" in value;
}

function workWithComedian(value: Comedian) {
  if (isStandupComedian(value)) {
    console.log(value.routine); // Ok, StandupComedian 타입으로 좁혀짐
  } else {
    console.log("Routine not found"); // value는 Comedian 타입으로 좁혀짐
  }
}
```

- 주의 사항

  - `false` 조건에서도 타입을 좁힌다.

  ```tsx
  function isLongString(input: string | undefined): input is string {
    return !!(input && input.length >= 7);
  }

  function workWithText(text: string | undefined) {
    if (isLongString(text)) {
      console.log("Long text:", text.length); // text는 string 타입
    } else {
      console.log("Short text:", text?.length); // text는 undefined 타입
    }
  }
  ```

### 타입 연산자

타입스크립트는 **keyof**와 **typeof** 같은 타입 연산자를 제공하여 기존 타입이나 값의 속성에서 유효한 키를 추출하거나, 값의 타입을 동적으로 참조할 수 있도록 지원한다.

1. `keyof`

   - 객체 타입에서 **유효한 키들의 유니언 타입**을 생성한다.
   - 특정 객체의 키들로만 제한된 매개변수를 설정하거나, 객체의 키에 대한 타입을 동적으로 참조할 때 유용하다.

   ```tsx
   interface Ratings {
     audience: number;
     critic: number;
   }

   function getRating(ratings: Ratings, key: keyof Ratings): number {
     return ratings[key]; // Ok
   }

   const ratings: Ratings = { audience: 66, critic: 84 };
   getRating(ratings, "audience"); // Ok
   getRating(ratings, "not valid"); // Error: 'not valid'는 'audience' | 'critic'에 할당할 수 없음
   ```

   - `keyof Ratings`는 `"audience" | "critic"`과 동일하게 작동하며, `Ratings` 인터페이스의 변경에 따라 자동으로 업데이트된다.

2. `typeof`

   - 타입스크립트의 `typeof`는 변수의 **타입을 가져오는 타입 연산자**이다.
   - 타입을 명시적으로 지정하지 않고도 기존 값의 타입을 자동으로 참조하여 변수를 선언할 수 있어 유용하다.

   ```tsx
   const original = { medium: "movie", title: "Mean Girls" };
   let adaptation: typeof original;

   if (Math.random() > 0.5) {
     adaptation = { ...original, medium: "play" }; // Ok
   } else {
     adaptation = { ...original, medium: 2 }; // Error: 'number' 타입은 'string'에 할당 불가
   }
   ```

   - `typeof original`을 사용하여 `adaptation` 변수는 `original`과 동일한 타입을 갖게 되므로, `medium` 속성에 `string`만 할당할 수 있다.

3. `keyof typeof`

   - `typeof`로 값의 타입을 가져온 다음, `keyof`를 사용해 해당 타입의 **유효한 키들의 유니언 타입**을 생성할 수 있다.
   - 이는 객체 리터럴의 키를 동적으로 참조하는 경우 인터페이스 없이 안전하게 키를 검증하는 데 유용하다.

   ```tsx
   const ratings = { imdb: 8.4, metacritic: 82 };

   function logRating(key: keyof typeof ratings) {
     console.log(ratings[key]);
   }

   logRating("imdb"); // Ok
   logRating("invalid"); // Error: 'invalid'는 'imdb' | 'metacritic'에 할당할 수 없음
   ```

   - `keyof typeof ratings`는 `"imdb" | "metacritic"`과 같은 유니언 타입을 생성하므로, `logRating` 함수에서 `ratings` 객체에 존재하지 않는 키를 전달하려고 할 때 컴파일 오류가 발생한다.

### 타입 어서션

타입스크립트 타입 시스템이 정확히 알지 못하는 값을 특정 타입으로 간주할 수 있게 해주는 기능

1. 기본 개념

   - `as` 키워드를 사용하여 특정 값의 타입을 명시적으로 지정할 수 있다.
   - 타입스크립트가 이 값을 명시된 타입으로 취급하도록 강제할 수 있다.

   ```tsx
   const rawData = '["grace", "frankie"]';
   const parsedData = JSON.parse(rawData) as string[]; // JSON 파싱 결과를 string[]으로 간주
   ```

2. 포착된 오류 타입 어서션
   - `try-catch` 구문에서 오류가 항상 특정 타입(`Error`)이라고 확신하는 경우 타입 어서션을 사용하여 해당 타입으로 간주할 수 있다.
   - 단, `instanceof`를 사용하여 타입을 좁히는 것이 더 안전하다.
3. non-null 어서션 (`!`)

   - 변수가 `null`이나 `undefined`가 아님을 확신할 때 `!`를 사용하여 non-null 어서션을 적용할 수 있다.
   - 이 연산자는 타입에서 `null`과 `undefined`를 제거하여 컴파일러에 변수가 항상 정의되어 있다고 알려준다.

   ```tsx
   const seasonCounts = new Map([["I Love Lucy", 6]]);
   const knownValue = seasonCounts.get("I Love Lucy")!; // undefined가 아님을 확신
   console.log(knownValue.toString());
   ```

4. 주의 사항
   - 타입 어서션은 타입스크립트의 타입 검사를 우회할 수 있어 위험할 수 있으며, 잘못된 타입으로 인해 런타임 오류를 발생시킬 수 있다.
   - 가능하면 정확한 타입 정의와 타입 가드를 통해 타입을 안전하게 좁히는 것이 좋다.
5. 이중 타입 어서션

   - 관련 없는 두 타입 사이에서 타입을 강제로 변환하려면 `unknown`이나 `any` 타입을 중간에 거쳐야 한다.
   - 이중 타입 어서션은 위험하며, 대부분의 경우 타입 정의가 잘못되었음을 나타내므로 피하는 것이 좋다.

   ```tsx
   let myValue = "1337" as unknown as number; // 허용되지만 위험하고 권장되지 않음
   ```

### const 어서션

**const 어서션**(`as const`)은 **값을 상수로 취급하도록 강제**하여 더 구체적인 타입을 부여할 수 있게 한다. 이를 통해 리터럴 타입을 유지하고 객체의 속성을 읽기 전용으로 만드는 등 타입 안정성을 높일 수 있다.

1. 규칙

   - **배열**은 가변 배열이 아닌 **읽기 전용 튜플**로 취급된다.
   - **리터럴**은 일반적인 원시 타입(`string`, `number`, `boolean`) 대신 **리터럴 타입**으로 취급된다.
   - **객체 속성**은 **읽기 전용**으로 간주된다.

1. 리터럴에서 원시 타입으로의 확장 방지

   - `as const`는 리터럴 값을 보다 구체적인 타입으로 유지하는 데 유용하다.
   - 예를 들어, 함수가 특정 리터럴 값을 반환해야 하는 경우 `as const`를 사용하여 반환 타입을 명확히 할 수 있다.

   ```tsx
   const getName = () => "Maria Bamford"; // 타입: () => string
   const getNameConst = () => "Maria Bamford" as const; // 타입: () => "Maria Bamford"
   ```

   - `getNameConst` 함수의 반환 타입은 `"Maria Bamford"`로 구체화되어, 이 함수의 반환값이 항상 `"Maria Bamford"`라는 특정 문자열임을 타입 시스템에 알릴 수 있다.

1. 객체의 읽기 전용 필드

   - `as const`를 사용하면 객체 리터럴의 속성도 읽기 전용으로 설정된다.
   - 특정 리터럴 타입을 요구하는 경우에도 유용하게 사용할 수 있다.

   ```tsx
   interface Joke {
     quote: string;
     style: "story" | "one-liner";
   }

   const narrowJoke = {
     quote: "If you stay alive for no other reason do it for spite.",
     style: "one-liner" as const, // 타입: "one-liner"
   };

   function tellJoke(joke: Joke) {
     console.log(joke.quote);
   }

   tellJoke(narrowJoke); // Ok

   const wideObject = {
     quote: "Time flies when you are anxious!",
     style: "one-liner", // 타입: string
   };

   tellJoke(wideObject); // Error: 'style'은 string이므로 "story" | "one-liner"에 맞지 않음
   ```

   - `narrowJoke`에서 `style` 속성은 `"one-liner"`로 고정되어 있지만, `wideObject`는 `string` 타입으로 확장되어 `Joke` 타입과 호환되지 않게 된다.

1. 읽기 전용 객체와 `as const`

   - `as const`를 사용하면 객체 리터럴의 모든 속성이 **읽기 전용**으로 설정되며, 값은 가능한 한 구체적인 타입으로 유추된다.
   - 예를 들어, `preferencesReadonly`의 모든 필드는 상수 리터럴 타입으로 유지된다.

   ```tsx
   const preferencesMutable = {
     movie: "maybe",
     standup: "yes",
   };

   preferencesMutable.movie = "no"; // Ok

   const preferencesReadonly = {
     movie: "maybe",
     standup: "yes",
   } as const;

   preferencesReadonly.movie = "no"; // Error: 읽기 전용 속성이라 수정 불가
   ```

   - `preferencesReadonly`는 `as const`로 선언되어 모든 필드가 `readonly`로 설정되며, 각 속성은 리터럴 타입으로 유지된다.
