## #1 타입 시스템

### 타입

> ❓ **타입**
> 자바스크립트에서 다루는 값의 형태

> ❓ `Number !== number`
> Number나 Boolean과 같은 객체는 원시 타입이 아닌 object 타입이다.

- 원시 타입
  - `null`
  - `undefined`
  - `boolean`
  - `string`
  - `number`
  - `bigint`
  - `symbol`
- 타입 시스템
  - 프로그래밍 언어가 프로그램에서 가질 수 있는 타입을 이해하는 방법에 대한 규칙 집합
- 오류

  - 구문 오류
    - 타입스크립트가 코드로 이해할 수 없는 잘못된 구문을 감지할 때 발생하며, 이는 타입스크립트 파일에서 자바스크립트 파일을 올바르게 생성할 수 없도록 차단한다.
  - 타입 오류
    - 타입 검사기가 프로그램의 타입에서 오류를 감지했을 때 발생하며, 오류가 발생해도 자바스크립트로 변환되는 것을 차단하진 않는다.

- `null` : 의도적으로 값이 없음을 나타낸다.
- `undefined` : 변수가 정의되지 않았거나 초기화되지 않은 상태를 나타낸다.
  - `null`과 `undefined`를 한 번에 처리하려면 `==` 연산자를, 각기 다르게 동작 시키려면 `===` 연산자를 사용해야 한다.
    - `==` 연산자 사용 시, 타입 강제 변환이 일어나 `null`과 `undefined`를 동등하게 간주한다.
- `void` : 함수가 아무 값도 반환하지 않는 상태를 나타낸다.
- `never` : 절대 반환 되지 않는 상태 → 함수가 끝나지 않거나 오류를 던질 때 사용한다.
- `any` : 어떠한 타입도 될 수 있는 상태로 타입 검사를 건너뛰고 사용할 수 있어 타입 안정성을 해치기 때문에 사용을 지양한다.
- `unknown` : 알 수 없는 값을 나타내며 사용하기 전에 구체적인 타입 검사를 해야 한다. any와 비슷하지만 더 안전하다.

### 할당 가능성

- 변수에 새로운 값이 할당되면, 새롭게 할당된 값의 타입이 변수의 타입과 동일한지 확인한다.
- 함수 호출이나 변수에 값을 제공할 수 있는지 여부를 확인하는 것을 할당 가능성이라고 한다.

### 타입 애너테이션

- 진화하는 `any` : 초기 타입을 유추할 수 없는 변수
- any 타입을 가진 값에는 타입스크립트의 타입 검사 기능을 잘 적용할 수 없다.
- `: type` : 초깃값을 할당하지 않고도 변수의 타입을 선언할 수 있는 구문
  - `let rocker: string;`
- 런타임 코드에 영향을 주지도 않고 유효한 자바스크립트 구문도 아니다.
  - 자바스크립트 코드로 컴파일 될 때 삭제된다.

---

## #2 유니언과 리터럴

### 유니언 타입 |

> ❓ **유니언**
> 값에 허용된 타입을 두 개 이상의 가능한 타입으로 **확장하는 것**

- 값이 정확히 어떤 타입인지 모르지만 두 개 이상의 옵
  션 중 하나라는 것을 알고 있는 경우에 사용
- `let thinker: string | null = null;`
- 유니언으로 선언한 모든 가능한 타입에 존재하는 멤버 속성에만 접근할 수 있다.
  - `number | string` 타입의 변수는 두 타입에 모두 존재하는 `toString()`은 사용할 수 있지만, `toUppercase()`와 `toFixed()`는 사용할 수 없다.
  - `toUppercase()`를 사용하기 위해서는 변수가 `string` 타입임을 타입스크립트에 알려야 한다. → **내로잉**

### 내로잉

> ❓ **내로잉**
> 값에 허용된 타입이 하나 이상의 가능한 타입이 되지 않도록 **좁히는 것**

- **타입 가드 :** 내로잉을 하는 데 사용할 수 있는 논리적 검사
  - `typeof` 검사, `instanceof` 검사, `in` 검사
  - 사용자 정의 타입 가드 함수
- **리터럴 타입 내로잉** : 조건문을 통해 검사
- **타입 단언** : `as`
  - 특정 값이 특정 타입임을 명시적으로 선언하는 방법이지만, 타입 검사기를 무시하는 것이기 때문에 주의해야 한다.

### 리터럴 타입

> ❓ **원시 타입**
> 해당 타입의 가능한 모든 리터럴 값의 집합

- 좀 더 구체적인 버전의 원시 타입으로 **특정 원시값**을 타입으로 가진다.

```tsx
const philosopher = "Hypatia";
// philosopher의 타입은 "Hypatia"
```

- 할당 가능성
  ```tsx
  let someString: string;

  let ada: "Ada" = "Ada";
  someString = ada; // (O)

  let byron: "Byron" = "Byron";
  ada = byron; // (X)
  // Error : Type '"Byron'" is not assignable to type "'Ada"' .
  ```

### 엄격한 null 검사

> ❓ **falsy**
> false, 0, -0, 0n, “”, null, undefined, NaN

- 십억 달러의 실수
  - 다른 타입이 필요한 위치에서 null 값을 사용하도록 허용하는 많은 타입 시스템
  - `const firstName: string = null; // (O)`
  - `strictNullChecks`
    - `true` : null과 undefined를 타입으로 할당해야 사용할 수 있다. → **엄격한 null 검사**
    - `false` : null, undefined를 타입으로 지정하지 않아도 사용할 수 있다.
- `&&`와 `?`
  - falsy는 알 수 있지만 그게 어떤 타입인지는 알 수 없다.
- 초깃값이 없는 변수
  - `Error: Variable 'mathematician' is used before being assigned.`
  - 변수에 `undefined`가 포함되어 있다면 오류가 나타나지 않지만, 그게 아니라면 값이 할당되기 전 변수를 사용하면 위와 같은 에러가 발생한다.

### 타입 별칭

- `type TypeName = 타입`
- 타입 별칭은 애너테이션과 달리 타입스크립트의 타입 시스템에만 존재하는 것으로 런타임 코드에서는 참조할 수 없다.
- 타입 별칭 결합
  ```tsx
  type IdMaybe = Id | undefined | null; // Ok
  type Id = number | string;
  ```

---

## #3 객체

### 객체 타입

```tsx
let poetlater: {
  born: number;
  name: string;
};

type Poet = {
  born: number;
  name: string;
};

let poetlater2: Poet;
```

- 필드 값 대신 타입을 사용해 선언하며 별칭 객체 타입을 사용할 수 있다.
  - 객체 타입을 설명할 땐, 주로 `interface` 키워드를 주로 사용한다.

### 구조적 타이핑

> ❓ **자바스크립트는?**
> `덕 타입`
> 런타임에서 사용될 때까지 객체 타입을 검사하지 않는다.
> `덕 타이핑`
> 객체의 변수 및 메서드의 집합이 객체의 타입을 결정한다.

- 타입스크립트의 타입 시스템은 구조적으로 타입화되어 있다.
- 타입을 충족하는 모든 값을 해당 타입의 값으로 사용할 수 있다.
- **객체 타입을 할당하는 값에는 객체 타입의 필수 속성이 모두 있어야 한다.**
  - 객체의 속성이 일치하지 않으면 타입스크립트는 타입 오류를 발생시킨다.
- 객체 타입 내에 객체 타입을 중첩으로 사용할 수 있다.
  ```tsx
  type Poem = {
    author: {
      firstName: string;
      lastName: string;
    };
    name: string;
  };
  ```
- `?`를 추가해 선택적 속성임을 나타낼 수 있다.
  - `null`을 허용하려면 명시적으로 타입에 포함해야 한다.
  - `undefined`는 기본적으로 선택적 속성에 포함되어 있기 때문에 타입 값으로 명시하지 않아도 사용할 수 있다.
  ```tsx
  interface User {
    name: string;
    age?: number;
  }

  const user1: User = { name: "Charlie", age: undefined }; // O
  const user2: User = { name: "Dave", age: null }; // X
  ```

### 객체 타입 유니언

- 타입을 명시적으로 지정하지 않고 여러 객체를 조작하거나 비교할 때 자동으로 객체의 가능한 타입 들을 유추해서 유니언 타입을 생성한다.
  - 유니언 타입에서 객체 타입에 포함된 선택적 속성(`?`)은 각 구성 요소의 속성 중 하나일 뿐, 항상 존재하지 않을 수 있습니다.
- 명시적으로 객체 타입의 조합을 명시하면 항상 존재한다는 보장이 없는 속성에는 접근할 수 없다.
  - 이를 활용해 객체 타입을 좁힐 수도 있다.
- **판별 된 유니언**
  - 객체의 속성이 객체의 형태를 나타내도록 하며 객체의 타입을 가리키는 속성이 판별값이다.
  - 런타임에 타입 정보를 유지할 수 있다.
  ```tsx
  type PoemWithPages = {
    name: string;
    pages: number;
    type: "pages"; // <- 판별값
  };
  ```

### 교차 타입 &

- 여러 타입을 결합해 새로운 타입을 생성한다.

```tsx
type Artwork = {
  genre: string;
  name: string;
};

type Writing = {
  pages: number;
  name: string;
};

type WrittenArt = Artwork & Writing;
/*
{ 
	genre: string; 
	name: string; 
	pages : number; 
} 
*/
```

- 교차 타입을 사용할 때는 코드를 최대한 간결하게 유지하는 것이 좋다.
  - 긴 할당 가능성 오류를 불러일으킨다.
  - 두 개의 원시 타입을 교차 시, never 타입이 된다.

### 타입 공간과 값 공간

- 타입 공간
  - 타입이 정의되고 사용되는 영역으로 컴파일 타임에만 사용된다. 오로지 코드의 타입 검사를 위해 존재한다.
  - `interface`, `type`, `type alias` 등
- 값 공간
  - 자바스크립트가 런타임에 실행하는 값이 존재하는 공간으로 함수, 변수, 클래스의 인스턴스 등 실제로 런타임에 사용할 수 있는 모든 값들은 값 공간에 속한다.
