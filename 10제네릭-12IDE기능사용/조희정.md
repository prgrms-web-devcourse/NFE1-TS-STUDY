<br/><br/><br/>

<h1 align="center">Learning TypeScript 10~12</h1>

<br/>

# 제네릭

### 제네릭

- 타입을 특정하지 않고, 호출 시점에 따라 다양한 타입을 허용하는 구조를 만들기 위한 방법
- 제네릭을 통해 코드에서 매개변수와 반환 값 사이의 타입 관계를 정확하게 지정할 수 있다.

```tsx
function identity<T>(input: T): T {
  return input;
}
```

- 제네릭 타입 매개변수는 함수 호출마다 서로 다른 타입으로 지정될 수 있지만, 한 호출 내에서는 일관된 타입 관계를 유지한다.

### 제네릭 함수

1. 제네릭 함수 선언

   ```tsx
   function identity<T>(input: T): T {
     return input;
   }

   identity("me"); // 타입: "me"
   identity(123); // 타입: 123
   ```

   - 기본 함수 선언에 `<T>`와 같은 타입 매개변수를 추가하여 제네릭 함수로 만든다.

2. 화살표 함수의 제네릭

   ```tsx
   const identity = <T,>(input: T) => input;
   identity(123); // 타입: 123
   ```

   - 매개변수 목록 앞에 제네릭을 선언할 수 있다. JSX 파일에서는 구문 충돌을 방지하기 위해 제한이 있을 수 있다.
     - `<T>`를 태그로 해석되는 문제
       - 일반 함수로 변경
       - `React.FC` 로 타입 지정

3. 명시적 제네릭 호출 타입

   ```tsx
   function logWrapper<Input>(callback: (input: Input) => void) {
     return (input: Input) => {
       console.log("Input:", input);
       callback(input);
     };
   }

   // 명시적 타입 지정
   logWrapper<string>((input) => {
     console.log(input.length); // input이 string으로 인식됨
   });
   ```

   - 대부분 타입스크립트는 함수 호출에 사용된 인수를 기반으로 타입을 유추하지만 타입 추론이 불가능할 때는 명시적으로 타입 인수를 지정해 줄 수 있다.

4. 다중 타입 매개변수

   ```tsx
   function makeTuple<First, Second>(first: First, second: Second) {
     return [first, second] as const;
   }

   const tuple = makeTuple(true, "abc"); // 타입: readonly [boolean, string]
   ```

   - 제네릭 함수는 여러 타입 매개변수를 선언할 수 있으며, 함수 호출 시 각각에 대해 타입을 명시할 수 있다.

5. 제네릭 타입 인수의 개수

   ```tsx
   function makePair<Key, Value>(key: Key, value: Value) {
     return { key, value };
   }

   // 올바른 사용
   makePair("abc", 123); // 타입: { key: string; value: number }
   makePair<string, number>("abc", 123); // 타입: { key: string; value: number }

   // 오류: 타입 인수 1개만 제공
   makePair<string>("abc", 123); // Error: Expected 2 type arguments, but got 1.
   ```

   - 제네릭 함수 호출 시 타입 매개변수가 여러 개일 경우, 모두 명시하거나 모두 생략해야 한다.

### 제네릭 인터페이스

1. 선언

   ```tsx
   interface Box<T> {
     inside: T;
   }

   let stringyBox: Box<string> = { inside: "abc" }; // `inside`가 string 타입
   let numberBox: Box<number> = { inside: 123 }; // `inside`가 number 타입

   // 타입 오류 예시
   let incorrectBox: Box<number> = { inside: false };
   // Error: Type 'boolean' is not assignable to type 'number'.
   ```

2. 내장 인터페이스의 제네릭
   - 타입스크립트의 내장 `Array` 인터페이스도 제네릭 인터페이스로 정의되어 있다.
   - `Array<T>` → `T` : 배열에 저장된 데이터 타입
3. 유추된 제네릭 인터페이스 타입

   ```tsx
   interface LinkedNode<Value> {
     next?: LinkedNode<Value>;
     value: Value;
   }

   function getLast<Value>(node: LinkedNode<Value>): Value {
     return node.next ? getLast(node.next) : node.value;
   }

   // Value 타입이 Date로 유추됨
   let lastDate = getLast({ value: new Date("09-13-1993") });

   // Value 타입이 string으로 유추됨
   let lastFruit = getLast({
     next: { value: "banana" },
     value: "apple",
   });

   // 타입 오류 예시: 유추된 Value 타입이 number인데 boolean 사용
   let lastMismatch = getLast({
     next: { value: 123 },
     value: false, // Error: Type 'boolean' is not assignable to type 'number'.
   });
   ```

4. 제네릭 인터페이스의 타입 인수 필수 제공

   - 제네릭 인터페이스를 선언할 때 타입 매개변수를 요구하면, 이를 참조하는 모든 타입 애너테이션에서 타입 인수를 반드시 제공해야 한다.
     - 타입 매개변수에 기본 값을 제공하여 해결할 수 있다.

   ```tsx
   interface CrateLike<T> {
     contents: T;
   }

   // 타입 인수를 제공하지 않아 오류 발생
   let missingGeneric: CrateLike = { contents: "??" };
   // Error: Generic type 'CrateLike<T>' requires 1 type argument(s).
   ```

### 제네릭 클래스

1. 제네릭 클래스

   ```tsx
   class Secret<Key, Value> {
     key: Key;
     value: Value;

     constructor(key: Key, value: Value) {
       this.key = key;
       this.value = value;
     }

     getValue(key: Key): Value | undefined {
       return this.key === key ? this.value : undefined;
     }
   }

   const storage = new Secret(12345, "luggage"); // 타입: Secret<number, string>
   storage.getValue(1987); // 타입: string | undefined
   ```

2. 명시적 제네릭 클래스 타입

   - 클래스 인스턴스를 생성할 때 생성자 매개변수로부터 타입을 유추할 수 없는 경우 타입스크립트는 기본 값으로 `unknown`을 사용하기 때문에 이를 피하기 위해 명시적으로 타입 인수를 제공할 수 있다.

   ```tsx
   class CurriedCallback<Input> {
     #callback: (input: Input) => void;

     constructor(callback: (input: Input) => void) {
       this.#callback = (input: Input) => {
         console.log("Input: ", input);
         callback(input);
       };
     }

     call(input: Input) {
       this.#callback(input);
     }
   }

   new CurriedCallback<string>((input) => {
     console.log(input.length); // 타입: CurriedCallback<string>
   });
   ```

3. 제네릭 클래스 확장

   - 기본 클래스를 제네릭 타입으로 지정하여 확장할 수 있다.

   ```tsx
   class Quote<T> {
     lines: T;

     constructor(lines: T) {
       this.lines = lines;
     }
   }

   class SpokenQuote extends Quote<string[]> {
     speak() {
       console.log(this.lines.join("\n"));
     }
   }

   new SpokenQuote(["Greed is so destructive.", "It destroys everything"]);
   ```

4. 제네릭 인터페이스 구현

   - 인터페이스의 타입 매개변수를 클래스에서 정확히 지정해야 한다.

   ```tsx
   interface ActingCredit<Role> {
     role: Role;
   }

   class MoviePart implements ActingCredit<string> {
     role: string;
     speaking: boolean;

     constructor(role: string, speaking: boolean) {
       this.role = role;
       this.speaking = speaking;
     }
   }

   const part = new MoviePart("Miranda Priestly", true); // 타입: ActingCredit<string>
   ```

5. 메서드 제네릭

   - 클래스 메서드는 클래스 인스턴스와 별도로 제네릭 타입을 선언할 수 있다.

   ```tsx
   class CreatePairFactory<Key> {
     key: Key;

     constructor(key: Key) {
       this.key = key;
     }

     createPair<Value>(value: Value) {
       return { key: this.key, value };
     }
   }

   const factory = new CreatePairFactory("role");
   const numberPair = factory.createPair(10); // 타입: { key: string, value: number }
   const stringPair = factory.createPair("Sophie"); // 타입: { key: string, value: string }
   ```

6. 정적 클래스 제네릭

   - 정적 멤버는 인스턴스 타입 매개변수를 사용할 수 없다.
   - 정적 메서드는 고유의 제네릭 타입을 선언해야 한다.

   ```tsx
   class BothLogger<OnInstance> {
     instancelog(value: OnInstance) {
       console.log(value);
       return value;
     }

     static staticlog<OnStatic>(value: OnStatic) {
       console.log(value);
       return value;
     }
   }

   const logger = new BothLogger<number[]>();
   logger.instancelog([1, 2, 3]); // 타입: number[]
   BothLogger.staticlog([false, true]); // 타입: boolean[]
   BothLogger.staticlog<string>("Static message"); // 타입: string
   ```

### 제네릭 타입 별칭

1. 제네릭 타입 별칭

   - 타입에 매개변수를 추가하여 타입을 동적으로 생성할 수 있다.

   ```tsx
   type Nullish<T> = T | null | undefined;

   // 사용 예시
   let name: Nullish<string> = null; // string | null | undefined 타입
   let age: Nullish<number> = 25;
   ```

   - 특정 입력 타입과 출력 타입을 가지는 함수의 타입을 정의하는 데 유용하다.

   ```tsx
   type CreatesValue<Input, Output> = (input: Input) => Output;

   let creator: CreatesValue<string, number>;
   creator = (text) => text.length; // OK
   creator = (text) => text.toUpperCase(); // Error: string을 number로 반환할 수 없음
   ```

1. 제네릭 판별된 유니언

   - 판별된 유니언은 여러 타입 중 특정 속성에 따라 타입을 좁히는 내로잉 방식이다.

   ```tsx
   type Result<Data> = FailureResult | SuccessfulResult<Data>;

   interface FailureResult {
     error: Error;
     succeeded: false;
   }

   interface SuccessfulResult<Data> {
     data: Data;
     succeeded: true;
   }

   function handleResult(result: Result<string>) {
     if (result.succeeded) {
       // result 타입은 SuccessfulResult<string>
       console.log(`We did it! ${result.data}`);
     } else {
       // result 타입은 FailureResult
       console.error(`Awww... ${result.error}`);
     }
     // result.data;  // Error: data는 FailureResult에 존재하지 않음
   }
   ```

   - `succeeded` 속성에 따라 타입을 좁힌다.

### 제네릭 제한자

1. 제네릭 기본 값

   - 제네릭 타입 매개변수에 기본 값을 지정할 수 있다.

   ```tsx
   interface Quote<T = string> {
     value: T;
   }

   // 명시적으로 T를 number로 설정
   let explicit: Quote<number> = { value: 123 };

   // 기본값인 string 타입으로 설정됨
   let implicit: Quote = {
     value: "Be yourself. The world worships the original.",
   };

   // 타입 오류: 기본값 string과 일치하지 않음
   let mismatch: Quote = { value: 123 };
   // Error: Type 'number' is not assignable to type 'string'.
   ```

1. 이전 타입 매개변수를 기본 값으로 사용하기

   ```tsx
   interface KeyValuePair<Key, Value = Key> {
     key: Key;
     value: Value;
   }

   let allExplicit: KeyValuePair<string, number> = { key: "rating", value: 10 }; // Key와 Value 모두 명시적 타입
   let oneDefaulting: KeyValuePair<string> = { key: "rating", value: "ten" }; // Value는 Key를 따라 string이 됨
   ```

1. 순서 규칙

   - 모든 기본 타입 매개변수는 선언 목록에서 마지막에 위치해야 한다.

   ```tsx
   // 올바른 예시: 기본값이 없는 타입이 앞에 있고, 기본값이 있는 타입은 뒤에 있음
   function inTheEnd<First, Second, Third = number, Fourth = string>() {} // OK

   // 오류 예시: 기본값이 없는 타입 매개변수 Fourth가 기본값이 있는 Third 다음에 위치
   function inTheMiddle<First, Second = boolean, Third = number, Fourth>() {}
   // Error: Required type parameters may not follow optional type parameters.
   ```

### 제한된 제네릭 타입

1. `extends`를 이용한 제한된 제네릭 타입

   ```tsx
   interface WithLength {
     length: number;
   }

   function logWithLength<T extends WithLength>(input: T) {
     console.log(`Length: ${input.length}`);
     return input;
   }

   // 사용 예시
   logWithLength("No one can figure out your worth but you."); // 타입: string
   logWithLength([false, true]); // 타입: boolean[]
   logWithLength({ length: 123 }); // 타입: { length: number }

   // 오류 예시
   logWithLength(new Date()); // Error: 'Date' 타입에는 'length' 속성이 없음
   ```

   - `length` 속성이 있는 타입만 허용된다.

1. `keyof`와 제한된 타입 매개변수

   - `keyof` 연산자를 사용하여 제한된 제네릭 타입 매개변수를 특정 타입의 키로 제한할 수 있다.

   ```tsx
   function get<T, Key extends keyof T>(container: T, key: Key) {
     return container[key];
   }

   const roles = {
     favorite: "Fargo",
     others: ["Almost Famous", "Burn After Reading", "Nomadland"],
   };

   const favorite = get(roles, "favorite"); // 타입: string
   const others = get(roles, "others"); // 타입: string[]

   // 오류 예시
   const missing = get(roles, "extras"); // Error: 'extras'는 'favorite' | 'others'에 할당될 수 없음
   ```

   - `keyof` 없이 단순히 `key: keyof T`와 같은 방식으로 구현하면 특정 속성의 타입을 반환하는 대신 모든 속성 타입의 유니언을 반환할 수 있다.

   ```tsx
   function get<T>(container: T, key: keyof T) {
     return container[key];
   }

   const roles = {
     favorite: "Fargo",
     others: ["Almost Famous", "Burn After Reading", "Nomadland"],
   };

   const found = get(roles, "favorite"); // 타입: string | string[]
   ```

### Promise

- 타입스크립트에서 `Promise`는 비동기 작업이 성공(`resolve`) 또는 실패(`reject`)했을 때 결과값을 다룰 수 있도록 하는 제네릭 클래스이다.

1. `Promise` 생성

   - `Promise`는 생성 시 `Promise<Value>`처럼 `resolve`되는 값의 타입을 명시적으로 지정할 수 있다.
     - 명시적인 타입 인수가 없으면 기본 값으로 `unknown`이 된다.

   ```tsx
   // 타입: Promise<unknown>
   const resolvesUnknown = new Promise((resolve) => {
     setTimeout(() => resolve("Done!"), 1000);
   });

   // 타입: Promise<string>
   const resolvesString = new Promise<string>((resolve) => {
     setTimeout(() => resolve("Done!"), 1000);
   });
   ```

2. `then` 메서드를 사용한 타입 변환

   - `then` 메서드를 사용해 기존 `Promise`의 `resolve` 값을 받아 새로운 타입을 반환하는 콜백을 실행할 수 있다.

   ```tsx
   // 타입: Promise<string>
   const textEventually = new Promise<string>((resolve) => {
     setTimeout(() => resolve("Done!"), 1000);
   });

   // 타입: Promise<number>
   const lengthEventually = textEventually.then((text) => text.length);
   ```

3. `async` 함수와 `Promise`

   - async 키워드를 사용해 선언한 함수는 항상 Promise를 반환한다.
   - 함수 내에서 `await`을 사용하여 비동기 코드를 처리하며, 반환되는 값이 `Promise`가 아닌 경우 자동으로 `Promise.resolve`로 래핑된다.

   ```tsx
   // 직접적으로 Promise<number>를 반환
   async function lengthAfterSecond(text: string): Promise<number> {
     await new Promise((resolve) => setTimeout(resolve, 1000));
     return text.length;
   }

   // number를 직접 반환하지만 자동으로 Promise<number>로 래핑됨
   async function lengthImmediately(text: string): Promise<number> {
     return text.length;
   }
   ```

   - `async` 함수는 반환 타입을 명시하지 않아도 타입스크립트가 자동으로 `Promise` 타입으로 간주하며 `async` 함수가 `Promise` 타입이 아닌 값을 반환하려 하면 오류가 발생한다.

   ```tsx
   // 올바른 예시: async 함수가 Promise<string>을 반환함
   async function givesPromiseForString(): Promise<string> {
     return "Done!";
   }

   // 오류 예시: 반환 타입이 string으로 명시되었지만, async 함수에서는 Promise<string>으로 반환됨
   async function givesString(): string {
     return "Done!"; // Error: The return type of an async function must be a Promise
   }
   ```

### 제네릭 올바르게 사용하기

- 제네릭은 코드의 유연성과 타입 안정성을 높이는 강력한 도구이지만 과도하게 사용하면 코드가 복잡해지고 읽기 어려워질 수 있어 필요한 경우에만 사용하는 것이 중요하다.

1. 제네릭의 황금률

   - 제네릭 타입 매개변수가 코드에서 두 번 이상 사용이 되는지
   - 제네릭은 타입 간의 관계를 설명하기 위해 사용되기 때문에 매개변수가 한 번만 사용된다면 제네릭이 필요하지 않다.

1. 제네릭 명명 규칙

   - 제네릭 타입 매개변수의 표준 명명 규칙은 일반적으로 `T`를 첫 번째 타입 인수로 사용하고, 후속 타입 매개변수가 있으면 `U`, `V` 등을 사용한다.
   - 하지만, 타입의 역할이 분명한 경우에는 `S` (State), `K` (Key), `V` (Value) 등 의미 있는 약어를 사용하기도 한다.

   ```tsx
   // 단일 문자 이름은 가독성을 해칠 수 있음
   function labelBox<L, V>(l: L, v: V) {
     /* ... */
   }

   // 설명적인 이름 사용으로 가독성 향상
   function labelBox<Label, Value>(label: Label, value: Value) {
     /* ... */
   }
   ```

- 필요할 때만 사용
- 명확한 이름 사용
- 유틸리티 타입이나 복잡한 모듈에서 사용
  - 다양한 경우를 지원해야 할 때

# 선언 파일

### 선언 파일

- 타입스크립트의 선언 파일(`.d.ts`)은 런타임 코드를 포함하지 않고, 코드에서 사용할 타입 정보를 정의하는 데 중점을 둔다.

1. 기본 구조

   - `.d.ts` 파일은 주로 인터페이스, 타입, 모듈 등의 타입 정보를 포함하여 외부 코드에서 이 타입을 사용할 수 있도록 돕는다.

   ```tsx
   // types.d.ts
   export interface Character {
     catchphrase?: string;
     name: string;
   }

   // index.ts
   import { Character } from "./types";

   export const character: Character = {
     catchphrase: "Yee-haw!",
     name: "Sandy Cheeks",
   };
   ```

2. 선언 파일의 앰비언트 컨텍스트

   > 🤔 **앰비언트 컨텍스트**
   > 타입 정의가 실제 코드 구현에 존재하지 않고 외부 환경이나 전역적으로 제공되는 값을 기준으로 추론되황

   - 선언 파일에서 정의된 내용이 실제로 존재하는 값을 정의하지 않으며, 타입 선언만을 제공한다.
   - `.d.ts` 파일에는 임포트된 라이브러리나 다른 타입에 대한 타입 정보만 포함되며, 실제 런타임 코드(함수나 변수 할당)는 포함되지 않는다.

### 런타임 값 선언

1. declare 전역 변수 선언

   - 전역 변수, 함수, 클래스가 존재한다고 선언할 수 있다.
     - 실제 값을 할당하는 것은 아니다.

   ```tsx
   // types.d.ts
   declare let declaredVar: string; // 선언만 가능, 초기화는 불가
   declare function canGrantWish(wish: string): boolean;
   ```

2. 전역 변수 선언

   - `import`나 `export`가 없으면 해당 파일은 전역 스코프에서 선언된 것으로 간주된다.
     - 전역으로 선언된 값이나 타입은 애플리케이션의 모든 파일에서 접근 가능하다.

   ```tsx
   // globals.d.ts
   declare const version: string; // 모든 파일에서 사용 가능

   // version.ts
   export function logVersion() {
     console.log(`Version: ${version}`); // 전역에서 접근 가능
   }
   ```

3. 전역 인터페이스 병합

   - 타입스크립트에서는 동일한 이름을 가진 인터페이스는 병합될 수 있기 때문에 이를 활용해 전역 객체의 타입을 확장할 수 있다.

   ```tsx
   // types/window.d.ts
   interface Window {
     myVersion: string;
   }

   // index.ts
   console.log(`Window version is: ${window.myVersion}`);
   ```

4. declare global 전역 스코프 확장

   - 모듈 파일 안에서도 전역 스코프 확장이 필요한 경우 `declare global` 블록을 사용하여 전역 선언을 할 수 있다.
     - 전역 선언과 모듈 선언을 함께 사용할 때 유용하다.

   ```tsx
   // types/data.d.ts
   export interface Data {
     version: string;
   }

   // types/globals.d.ts
   import { Data } from "./data";
   declare global {
     const globallyDeclared: Data;
   }
   declare const locallyDeclared: Data; // 전역으로 확장되지 않음
   ```

   - `globallyDeclared`는 전역으로 사용할 수 있지만, `locallyDeclared`는 전역으로 확장되지 않고 현재 파일에서만 사용 가능하다.

### 내장된 선언

1. 내장 라이브러리 선언

   - 자바스크립트에서 Array, Function, Map 같은 내장 객체는 타입스크립트의 `lib.*.d.ts` 파일에서 선언된다.
   - 자바스크립트의 최소 지원 버전에 따라 다르게 포함되며 `target` 설정에 맞춰 필요한 라이브러리 선언 파일이 자동으로 로드된다.

   ```tsx
   // lib.es5.d.ts의 일부
   interface Array<T> {
     length: number;
   }

   // lib.es2015.d.ts의 일부
   interface NumberConstructor {
     readonly EPSILON: number;
     isFinite(number: unknown): boolean;
   }
   ```

2. DOM 선언
   - 웹 브라우저 환경에서는 자바스크립트의 DOM API가 사용되고 타입스크립트는 `lib.dom.d.ts` 파일을 통해 `document`, `localStorage`, `HTMLElement` 등의 브라우저에서 사용되는 전역 타입을 정의한다.
3. 라이브러리 설정과 `target` 옵션
   - 타입스크립트 프로젝트의 `tsconfig.json`에서 `target` 옵션을 설정하면, 해당 버전에 맞는 `lib` 파일이 자동으로 포함된다.

### 모듈 선언

1. 모듈 선언

   - `declare module "module-name"` 구문을 사용해 특정 모듈을 선언할 수 있다.
     - `"my-example-lib"`이라는 모듈을 선언하고, 그 모듈이 문자열 타입의 `value`라는 변수를 내보내는 것을 타입스크립트에 알린다.
     - 외부 라이브러리나 타입이 제공되지 않은 모듈을 사용해야 할 때 유용

   ```tsx
   // modules.d.ts
   declare module "my-example-lib" {
     export const value: string;
   }

   // index.ts
   import { value } from "my-example-lib";
   console.log(value); // 타입 안전하게 사용 가능
   ```

2. 와일드카드 모듈 선언

   - 와일드카드(`*`)를 사용한 모듈 선언은 특정 파일 확장자를 가진 모든 파일을 특정 타입으로 취급하도록 한다.

   > ⚠️ **주의**: 와일드카드 모듈 선언은 파일 경로의 정확성을 검증하지 않으므로 타입 안정성이 완벽히 보장되지 않는다. 일부 프로젝트에서는 Webpack 같은 빌드 시스템이나 별도의 `.d.ts` 파일을 생성하여 가져오기가 유효한지 확인한다.

   ```tsx
   // styles.d.ts
   declare module "*.module.css" {
     const styles: { [className: string]: string };
     export default styles;
   }

   // component.ts
   import styles from "./styles.module.css";
   console.log(styles.anyClassName); // 타입: string
   ```

   - CSS 모듈 파일을 `declare module "*.module.css"`로 선언하여 타입스크립트가 CSS 파일을 객체로 인식하게 할 수 있다.

### 패키지 타입

1. 패키지 타입 선언 파일 생성

   - 타입스크립트 컴파일러 옵션인 `declaration`을 사용하여 `.ts` 파일에서 `.d.ts` 타입 선언 파일을 자동으로 생성할 수 있다.

   ```tsx
   // index.ts
   export const greet = (text: string) => {
     console.log(`Hello, ${text}!`);
   };

   // 컴파일 결과
   // index.d.ts
   export declare const greet: (text: string) => void;

   // index.js
   export const greet = (text) => {
     console.log(`Hello, ${text}!`);
   };
   ```

2. 패키지 타입 의존성

   - 타입스크립트는 `node_modules` 디렉터리에서 `.d.ts` 파일을 자동으로 감지해 패키지 타입을 지원한다.

   ```tsx
   // 예시: @jest/globals 패키지의 타입 선언
   // node_modules/@jest/globals/index.d.ts
   export function describe(name: string, test: () => void): void;
   export function it(name: string, test: () => void): void;

   // node_modules/jest/index.d.ts
   import * as globals from "@jest/globals";
   declare global {
     const describe: typeof globals.describe;
     const it: typeof globals.it;
   }
   ```

3. 패키지 타입 노출
   - 타입스크립트 프로젝트가 `npm`에 배포될 때, `package.json`의 `types` 필드를 통해 루트 타입 선언 파일을 지정할 수 있다.
     - 지정하지 않을 시, 기본적으로 `indes.d.ts` 파일을 찾는다.

### DefinitelyTyped

1. DefinitelyTyped와 `@types` 패키지

   - DefinitelyTyped는 GitHub에서 활발하게 유지 관리되며, 커뮤니티가 자발적으로 기여하는 타입 정의 파일을 모아둔 저장소이다.
   - DT의 타입 정의 파일들은 npm의 `@types` 범위로 배포된다.

   ```tsx
   // 예시: React와 타입 정의를 사용하기 위한 package.json 설정
   {
     "dependencies": {
       "react": "^18.1.0"
     },
     "devDependencies": {
       "@types/react": "^18.0.9"
     }
   }
   ```

   - `@types` 패키지와 실제 라이브러리의 버전이 반드시 일치하지는 않으므로, 타입 정의와 라이브러리 간의 호환성을 주의해야 한다.

# IDE 기능 사용

### 코드 탐색

- **정의와 타입 정의**: `F12`, `Cmd/Ctrl + 클릭`, `Option/Alt + F12`를 사용해 빠르게 정의와 타입 정의로 이동할 수 있다.
- **참조 찾기**: `Shift + F12`, `Option/Alt + Shift + F12`로 참조 목록을 찾고, 파일을 열지 않고 참조 위치를 미리 확인할 수 있다.
- **구현 찾기**: 인터페이스와 추상 클래스의 구현을 탐색하고자 할 때 `Cmd/Ctrl + F12`를 사용해 모든 구현을 확인할 수 있다.

### 코드 작성

- 이름 완성 및 자동 가져오기
- 코드 액션과 빠른 수정
  - 코드 액션: `Cmd + .` , `Ctrl + .`
  - 이름 바꾸기: `F2` → 미리보기: `Shift + Enter`
- 리팩터링
  - 클래스/인터페이스 속성 추가
  - 오타 수정
  - 변수 추출

### 오류 처리

- **오류 확인과 이동**: 마우스 호버, `F8`, PROBLEMS 탭 등으로 오류를 빠르게 파악하고 이동할 수 있다.
- **전체 프로젝트 오류 추적**: watch 모드 (`tsc -w`)를 사용하여 모든 파일의 오류를 실시간으로 업데이트한다.
- **타입 이해와 중개 타입 활용**: 타입 정보를 빠르게 확인하고 복잡한 타입을 중개 타입으로 분리하여 관리할 수 있다.
